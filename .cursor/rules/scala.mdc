---
description: Scala 3 coding standards and conventions for the airline-tickets project
globs: **/*.scala
alwaysApply: false
---

# Scala 3 Project Standards

This project uses **Scala 3.7.4** with modern libraries including Ox, Tapir, Magnum, and follows functional programming principles with pragmatic OOP where needed.

## Core Architectural Patterns

### Dependency Injection
- Use **MacWire** for compile-time DI via `autowire` and `autowireMembersOf`
- Define dependencies in `Dependencies.scala` object
- No runtime DI frameworks (Spring, Guice, etc.)

```scala
// ✅ GOOD - MacWire compile-time DI
object Dependencies:
  def create(config: Config, db: DB): MyService =
    autowire[MyService](config, db)
```

### Error Handling
- Use `Either[Fail, T]` for operations that can fail
- Define failures in the `Fail` sealed hierarchy
- Use Ox's `either` and `.ok()` for monadic error composition

```scala
// ✅ GOOD - Using Either with Ox
def registerUser(login: String, email: String)(using DbTx): Either[Fail, User] = either:
  validateInput(login, email).ok()
  checkUserExists(login).ok()
  createUser(login, email)

// ❌ BAD - Throwing exceptions for business logic
def registerUser(login: String, email: String): User =
  if !isValid(login) then throw new IllegalArgumentException("Invalid login")
  createUser(login, email)
```

### Database Access
- Use **Magnum** for type-safe SQL queries
- Always use `(using DbTx)` context parameter for database operations
- Use `db.transactEither` for operations returning `Either`
- Use `db.transact` for operations that always succeed
- Define repository methods in `*Model` classes (e.g., `UserModel`)

```scala
// ✅ GOOD - Type-safe Magnum queries
def findByEmail(email: LowerCased)(using DbTx): Option[User] = 
  userRepo.findAll(Spec[User].where(sql"${u.emailLowerCase} = $email")).headOption

// ✅ GOOD - Transaction handling
val result = db.transactEither(userService.registerNewUser(login, email, password))
```

### HTTP Endpoints with Tapir
- Separate endpoint **descriptions** from **implementations**
- Define endpoint descriptions in companion object as public vals
- Implement endpoints in the class using `.handle` method
- Use `ServerEndpoints` trait for all API classes
- Use `EndpointsForDocs` trait in companion objects
- Group endpoints by feature (e.g., `UserApi`, `PasswordResetApi`)

```scala
// ✅ GOOD - Tapir endpoint pattern
class UserApi(auth: Auth[ApiKey], userService: UserService, db: DB) extends ServerEndpoints:
  import UserApi.*
  
  private val registerUserServerEndpoint = registerUserEndpoint.handle { data =>
    db.transactEither(userService.registerNewUser(data.login, data.email, data.password))
      .map(apiKey => Register_OUT(apiKey.id.toString))
  }
  
  override val endpoints = wireList

object UserApi extends EndpointsForDocs:
  val registerUserEndpoint = baseEndpoint.post
    .in("user" / "register")
    .in(jsonBody[Register_IN])
    .out(jsonBody[Register_OUT])
    .description("Registers a new user")
```

### Concurrency with Ox
- Use `Ox` for structured concurrency (virtual threads)
- Pass `(using Ox)` context parameter for concurrent operations
- Use `fork`, `forever`, `sleep` from Ox library
- Use `.discard` to explicitly ignore return values

```scala
// ✅ GOOD - Ox concurrency
def startProcesses()(using Ox): Unit =
  fork {
    forever {
      sleep(config.interval)
      processBatch()
    }
  }.discard
```

## Scala 3 Syntax Conventions

### End Markers
- Use `end` markers for long methods, classes, and objects
- Especially important for files with multiple nested scopes

```scala
// ✅ GOOD - End markers for clarity
class UserService(...) extends Logging:
  def registerNewUser(...): Either[Fail, ApiKey] = either:
    validateUserData(...).ok()
    checkUserDoesNotExist().ok()
    doRegister()
  end registerNewUser
end UserService
```

### Indentation-Based Syntax
- Use **significant indentation** (no braces) for Scala 3
- Use colons `:` instead of braces `{}`
- Avoid unnecessary parentheses in simple expressions

```scala
// ✅ GOOD - Scala 3 indentation syntax
def processUser(id: Id[User]): Either[Fail, User] =
  userModel.findById(id) match
    case Some(user) => Right(user)
    case None       => Left(Fail.NotFound("User not found"))
```

### Pattern Matching
- Align case clauses vertically
- Use `match` without braces

```scala
// ✅ GOOD - Clean pattern matching
status match
  case Active   => processActive()
  case Pending  => processPending()
  case Disabled => processDisabled()
```

### Given/Using (Context Parameters)
- Use `(using DbTx)` for database context
- Use `(using Ox)` for concurrency context
- Place context parameters last in parameter lists

```scala
// ✅ GOOD
def findUser(id: Id[User])(using DbTx): Option[User] = ...
```

### Derives Clauses
- Use `derives` for automatic codec generation
- Common for JSON codecs and schemas

```scala
// ✅ GOOD
case class Register_IN(login: String, email: String, password: String) 
  derives ConfiguredJsonValueCodec, Schema
```

## Naming Conventions

### Type Parameters
- Use descriptive names or single uppercase letters (`T`, `U`, `E`)
- For tagged types, use `Id[User]`, `Id[ApiKey]`, etc.

### Case Classes for DTOs
- Suffix input DTOs with `_IN`
- Suffix output DTOs with `_OUT`
- Define in companion object near endpoint definitions

```scala
// ✅ GOOD
case class Register_IN(login: String, email: String, password: String)
case class Register_OUT(apiKey: String)
```

### Model Classes
- Suffix repository/DAO classes with `Model` (e.g., `UserModel`, `EmailModel`)
- Suffix service classes with `Service` (e.g., `UserService`, `EmailService`)
- Suffix API classes with `Api` (e.g., `UserApi`, `PasswordResetApi`)

## Logging

### Logger Usage
- Extend `Logging` trait to get `logger` field
- Use SLF4J for all logging
- Use structured logging with meaningful context

```scala
// ✅ GOOD
class UserService(...) extends Logging:
  logger.debug(s"Registering new user: ${user.emailLowerCase}, with id: ${user.id}")
  logger.error("Failed to process", exception)
```

## Security & Validation

### Input Validation
- Always trim user input strings
- Validate before database operations
- Use case-insensitive comparisons for emails and logins (`.toLowerCased`)
- Provide user-friendly error messages

```scala
// ✅ GOOD
def registerNewUser(login: String, email: String, password: String): Either[Fail, ApiKey] =
  val loginClean = login.trim()
  val emailClean = email.trim()
  validateUserData(Some(loginClean), Some(emailClean), Some(password)).ok()
  // ... rest of logic
```

### Password Hashing
- Use **Password4j** with Argon2 for password hashing
- Store configuration in object constants
- Never log passwords or hashes

## Testing Patterns

### Test Structure
- Extend `BaseTest` for integration tests
- Use ScalaTest with `should` matchers
- Use `EitherValues` for `.value` extraction from Either
- Test descriptions follow pattern: `"endpoint" should "behavior" in { ... }`

```scala
// ✅ GOOD
class UserApiTest extends BaseTest with TestDependencies:
  "/user/register" should "register and ignore leading spaces" in {
    val (login, email, password) = requests.randomLoginEmailPassword()
    val response = requests.registerUser("   " + login + "   ", email, password)
    response.code shouldBe StatusCode.Ok
  }
```

## Type Safety

### Phantom Types
- Use `Id[T]` for type-safe IDs
- Use `LowerCased` for normalized strings
- Use `Hashed` for password hashes
- Use extension methods like `.asId[T]`, `.toLowerCased`, `.asHashed`

```scala
// ✅ GOOD - Type-safe IDs prevent mixing user IDs with API key IDs
val userId: Id[User] = idGenerator.nextId[User]()
val apiKeyId: Id[ApiKey] = idGenerator.nextId[ApiKey]()
```

## Common Anti-Patterns to Avoid

```scala
// ❌ BAD - Don't use return keyword
def compute(): Int =
  return 42  // Avoid explicit return

// ❌ BAD - Don't use var when val + functional style works
var result = ""
for item <- items do
  result = result + item

// ✅ GOOD - Functional style
val result = items.mkString

// ❌ BAD - Don't catch generic exceptions in business logic
try doSomething() catch case _: Exception => fallback()

// ✅ GOOD - Use Either for expected failures
def doSomething(): Either[Fail, Result] = ...
```

## Import Organization

- Group imports logically: standard library, third-party, project
- Use wildcard imports for common utilities from same package
- Import specific items from Tapir and Magnum DSLs

```scala
// ✅ GOOD
package pl.algocode.airline.user

import com.augustnagro.magnum.{DbTx, Repo, Spec, sql}
import pl.algocode.airline.Fail
import pl.algocode.airline.util.Strings.{Id, LowerCased, toLowerCased}
import ox.either.ok

import java.time.Instant
```

## Configuration

- Use **PureConfig** for type-safe configuration from `application.conf`
- Define config case classes with `derives ConfigReader`
- Wrap sensitive values in `Sensitive[T]` wrapper type

```scala
// ✅ GOOD
case class DBConfig(url: String, username: String, password: Sensitive[String]) 
  derives ConfigReader
```
